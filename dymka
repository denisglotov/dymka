#!/usr/bin/env python

from pprint import pprint
from web3 import Web3, HTTPProvider
import argparse
import json
import logging
import os
import traceback

parser = argparse.ArgumentParser(description='Iteract with ethereum network.',
                                 fromfile_prefix_chars='@')
parser.add_argument('command',
                    help='version, show, balance, deploy, status, receipt, query, send')
parser.add_argument('arguments', nargs='*',
                    help='optional arguments to the command')
parser.add_argument('-a', '--address',
                    help='contract address to send/call')
parser.add_argument('-c', '--contract',
                    help='contract name or its json path')
parser.add_argument('-d', '--dry', action='store_true',
                    help='dry run, do not transact')
parser.add_argument('-f', '--from', dest='from_account',
                    default=os.environ.get('WEB3_FROM', None),
                    help='account name to transact from, defaults to env WEB3_FROM')
parser.add_argument('-p', '--provider',
                    default=os.environ.get('WEB3_PROVIDER', 'http://localhost:8545'),
                    help='web3 proveder, defaults to env WEB3_PROVIDER or localhost:8545')
parser.add_argument('-t', '--to',
                    help='account address to transact to')
parser.add_argument('--chainId', type=int,
                    help='explicitly set chain id')
parser.add_argument('--password', type=argparse.FileType('r'),
                    help='pass phrase to unlock the from account, defaults to empty')
parser.add_argument('--gasPrice', type=int,
                    help='explicitly set gas price')
parser.add_argument('--nonce',
                    help='excplicitly set nonce')
parser.add_argument('--timeout', type=int, default=120,
                    help='timeout to wait after the transaction, default is 120s')
parser.add_argument('--value', type=int,
                    help='money amount to use in transaction')

group = parser.add_mutually_exclusive_group()
group.add_argument('-v', '--verbose', action='count',
                   help='verbose output')
group.add_argument('-q', '--quiet', action='count',
                   help='quiet output')

group = parser.add_mutually_exclusive_group()
group.add_argument('-e', '--estimate', '--estimateGas', action='store_true',
                    help='estimate gas for the tx and use it unless dry run')
group.add_argument('--gas', type=int,
                    help='explicitly set gas amount')

args = parser.parse_args()


def getLogger(defaultLevel):
    log = logging.getLogger('dymka')
    if args.verbose:
        defaultLevel -= 10*args.verbose
    if args.quiet:
        defaultLevel += 10*args.quiet
    log.setLevel(defaultLevel)
    stream = logging.StreamHandler()
    stream.setFormatter(logging.Formatter('%(levelname)s %(message)s'))
    log.addHandler(stream)
    return log


log = getLogger(logging.INFO)


def getJson(fname):
    with open(fname) as file:
        return json.load(file)


def getOptionalArguments(ord):
    if len(args.arguments) > ord:
        log.debug('Raw args %s', args.arguments[ord:])
        arguments = eval('[' + ','.join(args.arguments[ord:]) + ']')
        log.debug('Arguments: %s', arguments)
        return arguments


def getContractData(name):
    fname = name + '.json'
    if not os.path.isfile(fname):
        fname = name
    data = getJson(fname)
    contracts_section = data['contracts']
    contracts = [key for key in contracts_section.keys() if key.lower().endswith(name.lower())]
    if len(contracts) != 1:
        raise ValueError(f'Ambigous contract list {contracts} in json {fname} for contract {name}.')
    contract = contracts_section[contracts[0]]
    return contract['abi'], contract['bin']


def getAccount(w3, account_name):
    if os.path.isfile(args.from_account):
        password = args.password.read() if args.password else ''
        with open(args.from_account) as keyfile:
            encrypted_key = keyfile.read()
            return w3.eth.account.decrypt(encrypted_key, password)
    return args.from_account


def getAddress(w3, account_name):
    if account_name:
        return w3.eth.account.from_key(getAccount(w3, account_name)).address


def transact(w3, tx, private_key):
    status = {}
    if args.estimate:
        gas = w3.eth.estimateGas(tx)
        log.info('Gas estimated %s', gas)
        tx['gas'] = status['gas'] = gas
    if args.dry:
        log.info('Dry run requested, nothing more to do')
        return status
    signed = w3.eth.account.sign_transaction(tx, private_key=private_key)
    hash = w3.eth.sendRawTransaction(signed.rawTransaction)
    status['hash'] = hash.hex()
    log.info('Transaction hash: %s', hash.hex())
    try:
        w3.eth.waitForTransactionReceipt(hash, timeout=args.timeout)
    except Exception:
        raise ValueError('Timeout waiting ' + str(args.timeout) + 's for transaction ' +
                         hash.hex())
    status['receipt'] = dict(w3.eth.getTransactionReceipt(hash))
    return status


def buildContractSendTx(w3, opts):
    function_name = args.arguments[0]
    abi, _ = getContractData(args.contract)
    contract = w3.eth.contract(abi=abi, address=args.address)
    arguments = getOptionalArguments(1)
    func = contract.functions[function_name]
    func_bound = func(*arguments) if arguments else func()
    return func_bound.buildTransaction(opts)


def processAccounts(fn, name, *vargs):
    pprint(list(map(lambda a: a and {'account': a, name: fn(a)},
                    [*args.arguments, *filter(None, vargs)])))


def main():
    if args.command == 'version':
        print('Version: 0.1')
        return

    log.info('Using %s to connect web3...', args.provider)
    provider = HTTPProvider(args.provider)
    w3 = Web3(provider)
    address_from = getAddress(w3, args.from_account)

    if args.command == 'show':
        status = {'provider': args.provider}
        if address_from:
            status['name'] = args.from_account
            status['address'] = address_from
        pprint(status)
        return

    if args.command == 'gas':
        pprint(w3.eth.gasPrice)
        return

    if args.command == 'checksum':
        processAccounts(Web3.toChecksumAddress, 'checksummed', address_from, args.to)
        return

    if args.command == 'balance':
        processAccounts(w3.eth.getBalance, 'balance', address_from, args.to)
        return

    if args.command == 'nonce':
        processAccounts(w3.eth.getTransactionCount, 'nonce', address_from, args.to)
        return

    if args.command == 'exec':
        function = args.arguments[0]
        arguments = getOptionalArguments(1)
        res = provider.make_request(function, *arguments if arguments else [[]])
        pprint(res)
        return

    if args.command == 'status':
        hash = args.arguments[0]
        tx = w3.eth.getTransaction(hash)
        pprint(dict(tx))
        return

    if args.command == 'receipt':
        hash = args.arguments[0]
        receipt = w3.eth.getTransactionReceipt(hash)
        pprint(dict(receipt))
        return

    if args.command == 'call' or args.command == 'query':
        function_name = args.arguments[0]
        abi, _ = getContractData(args.contract)
        contract = w3.eth.contract(abi=abi, address=args.address)
        arguments = getOptionalArguments(1)
        func = contract.functions[function_name]
        tx = func(*arguments) if arguments else func()
        status = {'result': tx.call({'from': address_from})}
        pprint(status)
        return

    opts = {
        'from': address_from,
        'nonce': args.nonce or w3.eth.getTransactionCount(address_from)
    }
    for name in ['chainId', 'gas', 'gasPrice', 'value', 'to']:
        if vars(args)[name]:
            opts[name] = vars(args)[name]
    log.info('Transaction options: %s', opts)

    if args.command == 'deploy':
        abi, bin = getContractData(args.contract)
        contract = w3.eth.contract(abi=abi, bytecode=bin)
        arguments = getOptionalArguments(0)
        ctor = contract.constructor(*arguments) if arguments else contract.constructor()
        tx = ctor.buildTransaction(opts)
        status = transact(w3, tx, getAccount(w3, args.from_account))
        pprint(status)
        return

    if args.command == 'send' or args.command == 'invoke':
        tx = opts if not args.contract else buildContractSendTx(w3, opts)
        status = transact(w3, tx, getAccount(w3, args.from_account))
        pprint(status)
        return


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        if log.isEnabledFor(logging.DEBUG):
            traceback.print_exc()
        else:
            log.error(e)
